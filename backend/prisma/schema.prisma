generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

enum AccountStatus {
  ACTIVE
  FROZEN
  BLOCKED
}

enum GroupRole {
  OWNER
  ADMIN
  MEMBER
}

model User {
  id           String        @id @default(cuid())
  username     String        @unique
  displayName  String?
  passwordHash String
  role         UserRole      @default(USER)
  status       AccountStatus @default(ACTIVE)
  createdAt    DateTime      @default(now())
  avatarFileId String?       @unique
  devices      Device[]

  avatarFile   FileAsset?    @relation("avatarFile", fields: [avatarFileId], references: [id])
  files        FileAsset[]   @relation("ownerFiles")
  filesReceived FileAsset[]  @relation("recipientFiles")
  smartKeys    SmartKey[]
  groupMemberships GroupMember[]
  groupsOwned  Group[]       @relation("groupOwner")
  aliasesOwned ContactAlias[] @relation("aliasOwner")
  aliasesPeer  ContactAlias[] @relation("aliasPeer")
}

model Device {
  id              String   @id @default(cuid())
  userId          String
  name            String
  createdAt       DateTime @default(now())
  lastSeenAt      DateTime @default(now())

  // Signal-related public materials
  registrationId  Int?
  identityKeyPub  String?  // base64
  signedPreKeyId  Int?
  signedPreKeyPub String?  // base64
  signedPreKeySig String?  // base64

  user            User     @relation(fields: [userId], references: [id])
  oneTimePreKeys  OneTimePreKey[]
  incoming        MessageEnvelope[] @relation("incoming")
  outgoing        MessageEnvelope[] @relation("outgoing")
}

model OneTimePreKey {
  id        String   @id @default(cuid())
  deviceId  String
  keyId     Int
  pubKey    String   // base64
  createdAt DateTime @default(now())
  usedAt    DateTime?

  device    Device   @relation(fields: [deviceId], references: [id])

  @@unique([deviceId, keyId])
}

model MessageEnvelope {
  id                 String   @id @default(cuid())
  senderUserId       String
  senderDeviceId     String
  recipientUserId    String
  recipientDeviceId  String
  ciphertext         String   // base64
  createdAt          DateTime @default(now())
  deliveredAt        DateTime?

  senderDevice       Device   @relation("outgoing", fields: [senderDeviceId], references: [id])
  recipientDevice    Device   @relation("incoming", fields: [recipientDeviceId], references: [id])

  @@index([recipientDeviceId, deliveredAt, createdAt])
}

model InviteCode {
  code       String   @id
  createdAt  DateTime @default(now())
  expiresAt  DateTime
  maxUses    Int
  uses       Int      @default(0)
}

enum QrStatus {
  PENDING
  APPROVED
  EXPIRED
}

model QrLogin {
  token            String   @id
  status           QrStatus @default(PENDING)
  createdAt        DateTime @default(now())
  expiresAt        DateTime
  approvedByUserId String?
  issuedJwt        String?
}

enum FileKind {
  MESSAGE
  AVATAR
}

model FileAsset {
  id              String    @id @default(cuid())
  ownerUserId     String
  recipientUserId String?
  kind            FileKind
  originalName    String?
  mime            String?
  size            Int
  storagePath     String
  createdAt       DateTime  @default(now())

  owner           User      @relation("ownerFiles", fields: [ownerUserId], references: [id])
  recipient       User?     @relation("recipientFiles", fields: [recipientUserId], references: [id])
  avatarFor       User?     @relation("avatarFile")
}

model SmartKey {
  id          String   @id @default(cuid())
  userId      String
  deviceName  String?
  secretHash  String   @unique
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime?

  user        User     @relation(fields: [userId], references: [id])
}

model SmartKeyBind {
  token     String   @id
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime
}

model SmartKeyLogin {
  token            String   @id
  status           QrStatus @default(PENDING)
  createdAt        DateTime @default(now())
  expiresAt        DateTime
  approvedByUserId String?
  approvedByKeyId  String?
  issuedJwt        String?
}

model Group {
  id        String        @id @default(cuid())
  name      String
  ownerId   String
  createdAt DateTime      @default(now())

  owner     User          @relation("groupOwner", fields: [ownerId], references: [id])
  members   GroupMember[]
}

model GroupMember {
  id        String    @id @default(cuid())
  groupId   String
  userId    String
  role      GroupRole @default(MEMBER)
  createdAt DateTime  @default(now())

  group     Group     @relation(fields: [groupId], references: [id])
  user      User      @relation(fields: [userId], references: [id])

  @@unique([groupId, userId])
}

model ContactAlias {
  id          String   @id @default(cuid())
  ownerUserId String
  peerUserId  String
  alias       String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User     @relation("aliasOwner", fields: [ownerUserId], references: [id])
  peer        User     @relation("aliasPeer", fields: [peerUserId], references: [id])

  @@unique([ownerUserId, peerUserId])
  @@index([ownerUserId])
}
